\section*{Описание алгоритма решения}

Работа выполнена в виде библиотеки \verb|expressions|
и главного файла \verb|main.py|, использующего
библиотеку.

\subsection*{Главный скрипт main.py}

\verb|main.py| представляет собой бесконечный цикл
ввода выражений.
Цикл заканчивается, если введена пустая строка.
Перед каждым вводом об этом сообщается пользователю,
как и список доступных математических функций.

Нотация, в которой введено выражение, автоматически определяется
с помощью функции \verb|get_expression(expression)|,
которая пытается создать из введённой строки объект выражения и венуть его.
Если создание не получилось, возвращается \verb|None|,
а цикл начинается заново.

Если в выражении есть переменные,
пользователю предлагается ввести значение каждой из них.
Ввод обрабатывается на наличие ошибок.
После ввода в выражение подставляются значения переменных.

Далее введённое выражение конвертируется во все нотации.
На экран выводятся строковые репрезентации всех выражений,
а так же их вычисленные значения.
После этого цикл начинается сначала.

\subsection*{Нотации}

Создание нотации включает шаги:

\begin{enumerate}
    \item Токенизировать входную строку
    \item Провалидировать список токенов
        \subitem Задать значения переменных по умолчанию
        \subitem Выполнить предварительную валидацию (проверка corner cases).
        \subitem Попытаться вычислить выражение.
\end{enumerate}

\subsection*{Конвертация}

Так как нотаций три, возможны 6 видов конвертаций.
Для упрощения выполнения задачи были реализованы три алгоритма,
связывающих нотации "треугольником":
инфиксная в постфиксную,
постфиксная в префиксную,
префиксная в инфиксную.
Это позволяет конвертировать нотации "из любой в любую".
Например, для конвертации из инфиксной в префиксную,
нужно сначала конвертировать инфиксную в постфиксную,
а затем постфиксную в префиксную.